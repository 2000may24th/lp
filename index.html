<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSC WK5 최적화 세션</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Pretendard', sans-serif;
        }
        /* TailwindCSS focus ring 커스텀 */
        .focus-ring {
            @apply focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500;
        }
        /* 미세한 스크롤바 스타일 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #a5b4fc;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #818cf8;
        }
        canvas {
            cursor: crosshair;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 antialiased">

    <div class="container mx-auto p-4 lg:p-8">
        <!-- 헤더 -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-indigo-600">MSC WK5 최적화 세션 : 선형계획법 그래프 Solver</h1>
            <p class="mt-2 text-lg text-slate-600">실은 마음에 드는 LP 특화 그래핑 웹사이트가 없어서 그냥 직접 빌드해봤습니다. 깃헙 맞팔 대환영~</p>
            <p class="mt-2 text-lg text-slate-600">목적 함수와 제약 조건을 입력하고 시각적인 해를 찾아보세요.</p>
        </header>

        <!-- 메인 컨텐츠 영역 -->
        <main class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- 왼쪽: 컨트롤 패널 -->
            <div class="lg:col-span-4 bg-white p-6 rounded-2xl shadow-lg border border-slate-200 h-fit">
                <div class="space-y-6">
                    <!-- 1. 목적 함수 -->
                    <div>
                        <h2 class="text-xl font-semibold mb-3 text-slate-700">1. 목적 함수 (Objective Function)</h2>
                        <div class="flex items-center gap-3">
                            <select id="objective-type" class="block w-1/3 p-2 border border-slate-300 rounded-md shadow-sm focus-ring">
                                <option value="maximize" selected>최대화</option>
                                <option value="minimize">최소화</option>
                            </select>
                            <div class="flex items-center gap-2 w-2/3">
                                <span class="text-lg font-medium">Z =</span>
                                <input type="text" id="objective-function" value="3x + 5y" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus-ring" placeholder="예: 3x + 5y">
                            </div>
                        </div>
                    </div>

                    <!-- 2. 제약 조건 -->
                    <div>
                        <h2 class="text-xl font-semibold mb-3 text-slate-700">2. 제약 조건 (Constraints)</h2>
                        <div id="constraints-container" class="space-y-3">
                            <!-- 기본 제약 조건 예시 -->
                            <div class="flex items-center gap-2 constraint-item">
                                <input type="text" value="x + y <= 10" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus-ring constraint-input" placeholder="예: x + 2y <= 20">
                                <button onclick="removeConstraint(this)" class="p-2 text-slate-400 hover:text-red-500 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>
                                </button>
                            </div>
                            <div class="flex items-center gap-2 constraint-item">
                                <input type="text" value="2x + y <= 15" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus-ring constraint-input" placeholder="예: x + 2y <= 20">
                                <button onclick="removeConstraint(this)" class="p-2 text-slate-400 hover:text-red-500 transition-colors">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>
                                </button>
                            </div>
                        </div>
                        <button id="add-constraint" class="mt-4 w-full flex items-center justify-center gap-2 p-2 border-2 border-dashed border-slate-300 text-slate-500 rounded-md hover:border-indigo-400 hover:text-indigo-500 transition-all">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                            <span>제약 조건 추가</span>
                        </button>
                    </div>
                     <!-- 음수 아닌 조건 -->
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center">
                            <input id="non-negativity-x" type="checkbox" checked class="h-4 w-4 text-indigo-600 border-slate-300 rounded focus:ring-indigo-500">
                            <label for="non-negativity-x" class="ml-2 block text-sm text-slate-900">x &ge; 0</label>
                        </div>
                        <div class="flex items-center">
                            <input id="non-negativity-y" type="checkbox" checked class="h-4 w-4 text-indigo-600 border-slate-300 rounded focus:ring-indigo-500">
                            <label for="non-negativity-y" class="ml-2 block text-sm text-slate-900">y &ge; 0</label>
                        </div>
                    </div>
                    <!-- 실행 버튼 -->
                    <button id="solve-button" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-indigo-700 focus-ring transition-transform transform hover:scale-105">
                        그래프 그리기
                    </button>
                </div>

                <!-- 3. 고급 기능 -->
                <div class="mt-8 pt-6 border-t border-slate-200 space-y-4">
                    <h2 class="text-xl font-semibold text-slate-700">고급 기능 (Advanced)</h2>
                    <div class="bg-slate-100 p-4 rounded-lg">
                        <label for="show-objective-line" class="flex items-center justify-between cursor-pointer">
                            <span class="font-medium text-slate-800">목적 함수 등고선 조작</span>
                            <div class="relative">
                                <input type="checkbox" id="show-objective-line" class="sr-only peer">
                                <div class="w-11 h-6 bg-slate-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-slate-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                            </div>
                        </label>
                        <div id="objective-slider-container" class="mt-3 hidden">
                            <label for="objective-slider" class="block text-sm font-medium text-slate-600 mb-1">Z 값 조정: <span id="z-value-label"></span></label>
                            <input type="range" id="objective-slider" min="0" max="100" value="50" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div>

            </div>

            <!-- 오른쪽: 그래프 및 결과 -->
            <div class="lg:col-span-8 space-y-8">
                <!-- 그래프 영역 -->
                <div class="bg-white p-4 sm:p-6 rounded-2xl shadow-lg border border-slate-200">
                    <div class="flex justify-between items-center mb-4">
                         <h2 class="text-xl font-semibold text-slate-700">그래프 시각화</h2>
                         <button id="export-png-button" class="text-sm bg-slate-100 text-slate-700 font-medium py-2 px-4 rounded-lg hover:bg-slate-200 transition-colors">
                            PNG로 내보내기
                        </button>
                    </div>
                    <div class="relative w-full aspect-square bg-slate-50 rounded-lg border border-slate-200">
                        <canvas id="lp-canvas"></canvas>
                        <div id="tooltip" class="absolute bg-black bg-opacity-70 text-white text-xs rounded py-1 px-2 pointer-events-none opacity-0 transition-opacity"></div>
                    </div>
                </div>

                <!-- 결과 영역 -->
                <div id="results-container" class="bg-white p-6 rounded-2xl shadow-lg border border-slate-200 hidden">
                    <h2 class="text-xl font-semibold mb-4 text-slate-700">분석 결과</h2>
                    <div id="solution-summary" class="p-4 rounded-lg mb-4 text-center">
                        <!-- 최적해 정보가 여기에 표시됩니다. -->
                    </div>
                    <div>
                        <h3 class="font-semibold mb-2 text-slate-600">꼭짓점 및 목적 함수 값</h3>
                        <div class="overflow-x-auto">
                            <table class="w-full text-sm text-left text-slate-500">
                                <thead class="text-xs text-slate-700 uppercase bg-slate-100">
                                    <tr>
                                        <th scope="col" class="px-6 py-3 rounded-l-lg">꼭짓점 (Vertex)</th>
                                        <th scope="col" class="px-6 py-3">X 좌표</th>
                                        <th scope="col" class="px-6 py-3">Y 좌표</th>
                                        <th scope="col" class="px-6 py-3 rounded-r-lg">Z 값</th>
                                    </tr>
                                </thead>
                                <tbody id="vertices-table-body">
                                    <!-- 꼭짓점 정보가 여기에 동적으로 추가됩니다. -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <!-- NEW: 민감도 분석 -->
                    <div id="sensitivity-analysis-container" class="mt-8 hidden">
                        <h3 class="font-semibold mb-3 text-slate-600">민감도 분석 (Sensitivity Analysis)</h3>
                        <div class="space-y-6">
                            <!-- 목적 함수 계수 범위 -->
                            <div>
                                <h4 class="font-medium text-sm text-slate-500 mb-2">목적 함수 계수 범위 (Range of Optimality)</h4>
                                <p class="text-xs text-slate-400 mb-2">현재 최적해 꼭짓점이 유지되는 각 계수의 범위입니다.</p>
                                <div class="overflow-x-auto">
                                    <table class="w-full text-sm text-left text-slate-500">
                                        <thead class="text-xs text-slate-700 uppercase bg-slate-100">
                                            <tr>
                                                <th scope="col" class="px-6 py-3 rounded-l-lg">계수 (Coeff)</th>
                                                <th scope="col" class="px-6 py-3">하한 (Lower)</th>
                                                <th scope="col" class="px-6 py-3">현재 값 (Current)</th>
                                                <th scope="col" class="px-6 py-3 rounded-r-lg">상한 (Upper)</th>
                                            </tr>
                                        </thead>
                                        <tbody id="optimality-range-table-body">
                                            <!-- 내용이 여기에 동적으로 추가됩니다. -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <!-- 제약조건 잠재 가격 -->
                            <div>
                                <h4 class="font-medium text-sm text-slate-500 mb-2">제약 조건 잠재 가격 (Shadow Prices)</h4>
                                <p class="text-xs text-slate-400 mb-2">각 제약 조건의 우변(RHS)이 1단위 증가할 때 목적 함수 값이 얼마나 변하는지를 나타냅니다.</p>
                                 <div class="overflow-x-auto">
                                    <table class="w-full text-sm text-left text-slate-500">
                                        <thead class="text-xs text-slate-700 uppercase bg-slate-100">
                                            <tr>
                                                <th scope="col" class="px-6 py-3 rounded-l-lg" style="width: 60%;">제약 조건 (Constraint)</th>
                                                <th scope="col" class="px-6 py-3 rounded-r-lg">잠재 가격 (Shadow Price)</th>
                                            </tr>
                                        </thead>
                                        <tbody id="shadow-price-table-body">
                                            <!-- 내용이 여기에 동적으로 추가됩니다. -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // 상수 및 전역 변수
        const EPSILON = 1e-9; // 부동소수점 비교를 위한 작은 값

        // DOM 요소 가져오기
        const canvas = document.getElementById('lp-canvas');
        const ctx = canvas.getContext('2d');
        const solveButton = document.getElementById('solve-button');
        const addConstraintButton = document.getElementById('add-constraint');
        const constraintsContainer = document.getElementById('constraints-container');
        const objectiveTypeSelect = document.getElementById('objective-type');
        const objectiveFunctionInput = document.getElementById('objective-function');
        const resultsContainer = document.getElementById('results-container');
        const solutionSummary = document.getElementById('solution-summary');
        const verticesTableBody = document.getElementById('vertices-table-body');
        const nonNegativityX = document.getElementById('non-negativity-x');
        const nonNegativityY = document.getElementById('non-negativity-y');
        
        const showObjectiveLineCheckbox = document.getElementById('show-objective-line');
        const objectiveSliderContainer = document.getElementById('objective-slider-container');
        const objectiveSlider = document.getElementById('objective-slider');
        const zValueLabel = document.getElementById('z-value-label');
        const tooltip = document.getElementById('tooltip');
        const exportPngButton = document.getElementById('export-png-button');

        let parsedConstraints = [];
        let feasibleVertices = [];
        let optimalSolution = null;
        let scale = 20;
        let origin = { x: 0, y: 0 };

        // --- 유틸리티 함수 ---
        function formatNumber(num) {
            // Ensure num is a number before calling methods on it.
            const numValue = typeof num === 'string' ? parseFloat(num) : num;
            
            if (isNaN(numValue)) {
                return "N/A"; // Or handle as an error
            }

            if (numValue === Infinity) return "∞";
            if (numValue === -Infinity) return "-∞";
            if (Math.abs(numValue) < EPSILON) return "0";
            if (Math.abs(numValue) > 10000 || (Math.abs(numValue) < 0.001 && Math.abs(numValue) > 0)) {
                return numValue.toExponential(2);
            }
            return parseFloat(numValue.toFixed(3)).toString();
        }

        function parseExpression(str) {
            str = str.replace(/\s/g, '');
            let xCoeff = 0, yCoeff = 0;

            const xMatch = str.match(/([+\-]?\d*\.?\d*)x/);
            if (xMatch) {
                if (xMatch[1] === '' || xMatch[1] === '+') xCoeff = 1;
                else if (xMatch[1] === '-') xCoeff = -1;
                else xCoeff = parseFloat(xMatch[1]);
            }
            
            const yMatch = str.match(/([+\-]?\d*\.?\d*)y/);
            if (yMatch) {
                if (yMatch[1] === '+' || yMatch[1] === '') yCoeff = 1;
                else if (yMatch[1] === '-') yCoeff = -1;
                else yCoeff = parseFloat(yMatch[1]);
            }
            return { x: xCoeff || 0, y: yCoeff || 0 };
        }

        function parseConstraint(str) {
            const match = str.match(/(.*?)(<=|>=|=)(.*)/);
            if (!match) return null;

            const coeffs = parseExpression(match[1]);
            const type = match[2];
            const value = parseFloat(match[3]);

            if (isNaN(coeffs.x) || isNaN(coeffs.y) || isNaN(value)) return null;

            return { coeffs, type, value, original: str };
        }
        
        function parseObjectiveFunction() {
            const str = objectiveFunctionInput.value;
            const coeffs = parseExpression(str);
            if (isNaN(coeffs.x) || isNaN(coeffs.y)) return null;
            return { coeffs };
        }
        
        // --- 이벤트 리스너 ---
        
        document.addEventListener('DOMContentLoaded', () => {
            const canvasContainer = canvas.parentElement;
            function resizeCanvas() {
                canvas.width = canvasContainer.clientWidth;
                canvas.height = canvasContainer.clientHeight;
                solveAndDraw();
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        });

        solveButton.addEventListener('click', solveAndDraw);

        addConstraintButton.addEventListener('click', () => {
            const newConstraint = document.createElement('div');
            newConstraint.className = 'flex items-center gap-2 constraint-item';
            newConstraint.innerHTML = `
                <input type="text" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus-ring constraint-input" placeholder="예: 3x + y >= 5">
                <button onclick="removeConstraint(this)" class="p-2 text-slate-400 hover:text-red-500 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>
                </button>
            `;
            constraintsContainer.appendChild(newConstraint);
            newConstraint.querySelector('input').focus();
        });

        function removeConstraint(button) {
            button.parentElement.remove();
        }

        showObjectiveLineCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                objectiveSliderContainer.style.display = 'block';
                updateSliderRange(true);
            } else {
                objectiveSliderContainer.style.display = 'none';
            }
            redraw();
        });

        objectiveSlider.addEventListener('input', () => {
            const zValue = parseFloat(objectiveSlider.value);
            zValueLabel.textContent = formatNumber(zValue);
            redraw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let found = false;
            for (const vertex of feasibleVertices) {
                const screenPos = toScreenCoords(vertex);
                const dist = Math.sqrt(Math.pow(mouseX - screenPos.x, 2) + Math.pow(mouseY - screenPos.y, 2));
                if (dist < 8) {
                    tooltip.style.left = `${e.clientX - rect.left + 15}px`;
                    tooltip.style.top = `${e.clientY - rect.top}px`;
                    tooltip.textContent = `(${formatNumber(vertex.x)}, ${formatNumber(vertex.y)})`;
                    tooltip.style.opacity = '1';
                    found = true;
                    break;
                }
            }

            if (!found) {
                tooltip.style.opacity = '0';
            }
        });
        
        exportPngButton.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'linear-programming-graph.png';
            link.href = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
            link.click();
        });

        // --- 핵심 로직 ---
        function solveAndDraw() {
            const constraintsInputs = Array.from(document.querySelectorAll('.constraint-input'));
            parsedConstraints = constraintsInputs.map(input => parseConstraint(input.value)).filter(c => c !== null);

            if (nonNegativityX.checked) parsedConstraints.push({ coeffs: {x: 1, y: 0}, type: '>=', value: 0, original: 'x &ge; 0'});
            if (nonNegativityY.checked) parsedConstraints.push({ coeffs: {x: 0, y: 1}, type: '>=', value: 0, original: 'y &ge; 0'});

            const objectiveFunction = parseObjectiveFunction();
            if (!objectiveFunction) {
                alert("목적 함수 형식이 올바르지 않습니다.");
                return;
            }

            const intersectionPoints = [];
            for (let i = 0; i < parsedConstraints.length; i++) {
                for (let j = i + 1; j < parsedConstraints.length; j++) {
                    const c1 = parsedConstraints[i];
                    const c2 = parsedConstraints[j];
                    const det = c1.coeffs.x * c2.coeffs.y - c1.coeffs.y * c2.coeffs.x;

                    if (Math.abs(det) > EPSILON) {
                        const x = (c2.coeffs.y * c1.value - c1.coeffs.y * c2.value) / det;
                        const y = (c1.coeffs.x * c2.value - c2.coeffs.x * c1.value) / det;
                        intersectionPoints.push({ x, y });
                    }
                }
            }
            
            feasibleVertices = intersectionPoints.filter(p => {
                return parsedConstraints.every(c => checkConstraint(c, p));
            });
            
            feasibleVertices = feasibleVertices.filter((v, i, a) => 
                a.findIndex(t => (Math.abs(t.x - v.x) < EPSILON && Math.abs(t.y - v.y) < EPSILON)) === i
            );
            
            if (feasibleVertices.length > 2) {
                const center = feasibleVertices.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0, y:0});
                center.x /= feasibleVertices.length;
                center.y /= feasibleVertices.length;
                feasibleVertices.sort((a, b) => {
                    const angleA = Math.atan2(a.y - center.y, a.x - center.x);
                    const angleB = Math.atan2(b.y - center.y, b.x - center.x);
                    return angleA - angleB;
                });
            }

            optimalSolution = findOptimalSolution(feasibleVertices, objectiveFunction);
            updateSliderRange(true);
            
            redraw();
            displayResults(objectiveFunction);
        }
        
        function redraw() {
            const objectiveFunction = parseObjectiveFunction();
            if (!objectiveFunction) return;

            clearCanvas();
            setupCoordinateSystem();
            drawGrid();
            drawAxes();
            drawFeasibleRegion(feasibleVertices);
            drawConstraintLines();
            drawVertices(feasibleVertices);
            
            if (optimalSolution && optimalSolution.vertex) {
                drawOptimalVertex(optimalSolution.vertex);
            }

            if (showObjectiveLineCheckbox.checked) {
                const zValue = parseFloat(objectiveSlider.value);
                drawObjectiveLine(objectiveFunction, zValue);
            } else {
                // Draw the optimal line by default if a solution exists
                if (optimalSolution && optimalSolution.type === 'optimal' && optimalSolution.vertex) {
                    drawObjectiveLine(objectiveFunction, optimalSolution.value);
                }
            }
        }

        function checkConstraint(constraint, point) {
            const val = constraint.coeffs.x * point.x + constraint.coeffs.y * point.y;
            switch (constraint.type) {
                case '<=': return val <= constraint.value + EPSILON;
                case '>=': return val >= constraint.value - EPSILON;
                case '=': return Math.abs(val - constraint.value) < EPSILON;
                default: return false;
            }
        }

        function findOptimalSolution(vertices, objective) {
            if (vertices.length === 0) {
                 let hasPositiveX = parsedConstraints.some(c=>c.original === 'x >= 0');
                 let hasPositiveY = parsedConstraints.some(c=>c.original === 'y >= 0');
                 if(hasPositiveX && hasPositiveY && parsedConstraints.length > 2) {
                     return { type: 'infeasible' };
                 }
            }
            
            let bestVertex = null;
            let bestValue = objectiveTypeSelect.value === 'maximize' ? -Infinity : Infinity;

            vertices.forEach(v => {
                const z = objective.coeffs.x * v.x + objective.coeffs.y * v.y;
                v.z = z;
                if (objectiveTypeSelect.value === 'maximize') {
                    if (z > bestValue) {
                        bestValue = z;
                        bestVertex = v;
                    }
                } else {
                    if (z < bestValue) {
                        bestValue = z;
                        bestVertex = v;
                    }
                }
            });
            
             if (vertices.length > 0 && bestVertex === null) {
                 return { type: 'unbounded' };
             }
             if (vertices.length === 0) return { type: 'infeasible' };

            return { type: 'optimal', vertex: bestVertex, value: bestValue };
        }
        
        function updateSliderRange(resetValue = false) {
            if (feasibleVertices.length > 0) {
                const zValues = feasibleVertices.map(v => v.z).filter(z => isFinite(z));
                if (zValues.length === 0) {
                     objectiveSlider.min = 0; objectiveSlider.max = 100; objectiveSlider.value = 50;
                     zValueLabel.textContent = "";
                     return;
                }

                const minZ = Math.min(...zValues);
                const maxZ = Math.max(...zValues);
                objectiveSlider.min = minZ;
                objectiveSlider.max = maxZ;
                
                if (resetValue && optimalSolution && optimalSolution.value !== undefined && isFinite(optimalSolution.value)) {
                    objectiveSlider.value = optimalSolution.value;
                }
                
                if (parseFloat(objectiveSlider.value) < minZ) objectiveSlider.value = minZ;
                if (parseFloat(objectiveSlider.value) > maxZ) objectiveSlider.value = maxZ;
                
                zValueLabel.textContent = formatNumber(objectiveSlider.value);
            } else {
                objectiveSlider.min = 0;
                objectiveSlider.max = 100;
                objectiveSlider.value = 50;
                zValueLabel.textContent = "";
            }
        }
        
        // --- 그리기 함수 ---

        function toScreenCoords(point) {
            return {
                x: origin.x + point.x * scale,
                y: origin.y - point.y * scale
            };
        }

        function clearCanvas() {
             ctx.fillStyle = '#f8fafc';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function setupCoordinateSystem() {
            let allPoints = feasibleVertices.length > 0 ? [...feasibleVertices] : [{x:10, y:10}];
            let maxX = 0, maxY = 0;
            allPoints.forEach(p => {
                maxX = Math.max(maxX, Math.abs(p.x));
                maxY = Math.max(maxY, Math.abs(p.y));
            });
            let maxDim = Math.max(maxX, maxY, 10) * 1.2;

            if (nonNegativityX.checked && nonNegativityY.checked) {
                 scale = Math.min( (canvas.width-80) / maxDim, (canvas.height-80) / maxDim);
                 origin = {x: 50, y: canvas.height - 50};
            } else {
                scale = Math.min(canvas.width / (2 * maxDim), canvas.height / (2 * maxDim));
                origin = { x: canvas.width / 2, y: canvas.height / 2 };
            }
        }
        
        function drawAxes() {
            ctx.beginPath();
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1.5;
            ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width, origin.y);
            ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height);
            ctx.stroke();
            ctx.fillStyle = '#334155';
            ctx.font = '14px Inter';
            ctx.fillText('x', canvas.width - 20, origin.y - 10);
            ctx.fillText('y', origin.x + 10, 20);
        }
        
        function calculateNiceStep(range, maxSteps) {
            if (range <= 0) return 1;
            const roughStep = range / maxSteps;
            const exponent = Math.floor(Math.log10(roughStep));
            const powerOf10 = Math.pow(10, exponent);
            const fraction = roughStep / powerOf10;

            let niceFraction;
            if (fraction <= 1) niceFraction = 1;
            else if (fraction <= 2) niceFraction = 2;
            else if (fraction <= 5) niceFraction = 5;
            else niceFraction = 10;
            
            return niceFraction * powerOf10;
        }

        function drawGrid() {
            ctx.beginPath();
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#64748b';
            ctx.font = '12px Inter';

            const viewWidth = canvas.width / scale;
            const viewHeight = canvas.height / scale;
            const step = calculateNiceStep(Math.max(viewWidth, viewHeight), 10);
            if (step <= 0) return;
            
            for (let i = 1; origin.x + i * step * scale < canvas.width; i++) {
                const x = i * step; const sx = origin.x + x * scale;
                ctx.moveTo(sx, 0); ctx.lineTo(sx, canvas.height);
                ctx.fillText(formatNumber(x), sx + 5, origin.y + 15);
            }
            for (let i = -1; origin.x + i * step * scale > 0; i--) {
                const x = i * step; const sx = origin.x + x * scale;
                ctx.moveTo(sx, 0); ctx.lineTo(sx, canvas.height);
                ctx.fillText(formatNumber(x), sx + 5, origin.y + 15);
            }
            for (let i = 1; origin.y - i * step * scale > 0; i++) {
                const y = i * step; const sy = origin.y - y * scale;
                ctx.moveTo(0, sy); ctx.lineTo(canvas.width, sy);
                ctx.fillText(formatNumber(y), origin.x + 5, sy - 5);
            }
            for (let i = -1; origin.y - i * step * scale < canvas.height; i--) {
                const y = i * step; const sy = origin.y - y * scale;
                ctx.moveTo(0, sy); ctx.lineTo(canvas.width, sy);
                ctx.fillText(formatNumber(y), origin.x + 5, sy - 5);
            }
            ctx.stroke();
        }
        
        function drawConstraintLines() {
            parsedConstraints.forEach(c => {
                ctx.beginPath();
                ctx.strokeStyle = '#a5b4fc'; ctx.lineWidth = 2;
                const { x: a, y: b } = c.coeffs; const val = c.value;
                let x1, y1, x2, y2;
                if (Math.abs(b) > EPSILON) {
                    x1 = (-origin.x) / scale; y1 = (val - a * x1) / b;
                    x2 = (canvas.width - origin.x) / scale; y2 = (val - a * x2) / b;
                } else if (Math.abs(a) > EPSILON) {
                    y1 = (canvas.height - origin.y) / scale; x1 = (val - b * y1) / a;
                    y2 = (-origin.y) / scale; x2 = (val - b * y2) / a;
                } else return;
                const p1 = toScreenCoords({x: x1, y: y1});
                const p2 = toScreenCoords({x: x2, y: y2});
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
        }
        
        function drawFeasibleRegion(vertices) {
            if (vertices.length < 2) return;
            if (vertices.length === 2) { 
                ctx.beginPath();
                const p1 = toScreenCoords(vertices[0]);
                const p2 = toScreenCoords(vertices[1]);
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 3;
                ctx.stroke();
                return;
            }
            ctx.beginPath();
            const startPoint = toScreenCoords(vertices[0]);
            ctx.moveTo(startPoint.x, startPoint.y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(toScreenCoords(vertices[i]).x, toScreenCoords(vertices[i]).y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(129, 140, 248, 0.3)'; ctx.fill();
            ctx.strokeStyle = '#6366f1'; ctx.lineWidth = 2; ctx.stroke();
        }

        function drawVertices(vertices) {
            vertices.forEach((v, index) => {
                const p = toScreenCoords(v);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = 'white'; ctx.fill();
                ctx.strokeStyle = '#4f46e5'; ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = '#1e293b'; ctx.font = 'bold 12px Inter';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(`V${index + 1}`, p.x, p.y - 15);
            });
            ctx.textAlign = 'start'; ctx.textBaseline = 'alphabetic';
        }

        function drawOptimalVertex(vertex) {
            const p = toScreenCoords(vertex);
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#f59e0b'; ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawObjectiveLine(objective, z) {
            if (isNaN(z) || !isFinite(z)) return;
            const {x: a, y: b} = objective.coeffs;
            if (Math.abs(a) < EPSILON && Math.abs(b) < EPSILON) return;
            
            ctx.beginPath();
            ctx.strokeStyle = '#f59e0b'; 
            ctx.lineWidth = 2; 
            ctx.setLineDash([5, 5]);
            
            let x1, y1, x2, y2;
             if (Math.abs(b) > EPSILON) {
                x1 = -origin.x / scale; y1 = (z - a * x1) / b;
                x2 = (canvas.width - origin.x) / scale; y2 = (z - a * x2) / b;
            } else {
                y1 = -origin.y / scale; x1 = (z - b * y1) / a;
                y2 = (canvas.height - origin.y) / scale; x2 = (z - b * y2) / a;
            }
            const p1 = toScreenCoords({x: x1, y: y1});
            const p2 = toScreenCoords({x: x2, y: y2});
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // --- 결과 표시 함수 ---
        function displayResults(objectiveFunction) {
            resultsContainer.classList.remove('hidden');
            solutionSummary.innerHTML = '';
            verticesTableBody.innerHTML = '';
            solutionSummary.classList.remove('bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800');

            if (optimalSolution.type === 'infeasible') {
                 solutionSummary.classList.add('bg-red-100', 'text-red-800');
                 solutionSummary.innerHTML = `<p class="font-bold">해가 없음 (Infeasible)</p><p>모든 제약 조건을 만족하는 영역이 존재하지 않습니다.</p>`;
                 document.getElementById('sensitivity-analysis-container').classList.add('hidden');
                 return;
            }
             if (optimalSolution.type === 'unbounded') {
                 solutionSummary.classList.add('bg-yellow-100', 'text-yellow-800');
                 solutionSummary.innerHTML = `<p class="font-bold">해가 무한함 (Unbounded)</p><p>목적 함수 값이 무한히 커지거나 작아질 수 있습니다.</p>`;
                 document.getElementById('sensitivity-analysis-container').classList.add('hidden');
                 return;
            }
            if(optimalSolution.type === 'optimal' && optimalSolution.vertex) {
                solutionSummary.classList.add('bg-green-100', 'text-green-800');
                const typeText = objectiveTypeSelect.value === 'maximize' ? '최댓값' : '최솟값';
                solutionSummary.innerHTML = `
                    <p class="font-bold">최적해 발견!</p>
                    <p><strong>(x, y) = (${formatNumber(optimalSolution.vertex.x)}, ${formatNumber(optimalSolution.vertex.y)})</strong>에서</p>
                    <p>목적 함수의 <strong>${typeText} Z = ${formatNumber(optimalSolution.value)}</strong> 입니다.</p>
                `;
            }

            feasibleVertices.forEach((v, index) => {
                const isOptimal = optimalSolution.vertex && Math.abs(v.x - optimalSolution.vertex.x) < EPSILON && Math.abs(v.y - optimalSolution.vertex.y) < EPSILON;
                const row = document.createElement('tr');
                row.className = isOptimal ? 'bg-amber-100 font-bold' : 'bg-white';
                row.innerHTML = `
                    <td class="px-6 py-4">V${index + 1}</td>
                    <td class="px-6 py-4">${formatNumber(v.x)}</td>
                    <td class="px-6 py-4">${formatNumber(v.y)}</td>
                    <td class="px-6 py-4">${formatNumber(v.z)}</td>
                `;
                verticesTableBody.appendChild(row);
            });
            calculateAndDisplaySensitivityAnalysis(objectiveFunction);
        }
        
        function calculateAndDisplaySensitivityAnalysis(objectiveFunction) {
            const sensitivityContainer = document.getElementById('sensitivity-analysis-container');
            const optimalityBody = document.getElementById('optimality-range-table-body');
            const shadowBody = document.getElementById('shadow-price-table-body');
            optimalityBody.innerHTML = ''; shadowBody.innerHTML = '';

            if (!optimalSolution || optimalSolution.type !== 'optimal' || !optimalSolution.vertex) {
                sensitivityContainer.classList.add('hidden'); return;
            }
            sensitivityContainer.classList.remove('hidden');
            const v_opt = optimalSolution.vertex;
            const c1 = objectiveFunction.coeffs.x; const c2 = objectiveFunction.coeffs.y;

            const bindingConstraints = parsedConstraints.filter(c => 
                Math.abs(c.coeffs.x * v_opt.x + c.coeffs.y * v_opt.y - c.value) < EPSILON
            );

            if (bindingConstraints.length >= 2) {
                const slopes = [];
                bindingConstraints.forEach(c => {
                    if (Math.abs(c.coeffs.y) > EPSILON) slopes.push(-c.coeffs.x / c.coeffs.y);
                    else if (Math.abs(c.coeffs.x) > EPSILON) slopes.push(c.coeffs.x > 0 ? Infinity : -Infinity);
                });
                const minSlope = Math.min(...slopes); const maxSlope = Math.max(...slopes);

                let c1_l = -Infinity, c1_u = Infinity, c2_l = -Infinity, c2_u = Infinity;
                if (Math.abs(c2) > EPSILON) {
                    const b1 = -c2 * minSlope; const b2 = -c2 * maxSlope;
                    c1_l = Math.min(b1, b2); c1_u = Math.max(b1, b2);
                }
                if (Math.abs(c1) > EPSILON) {
                    if (minSlope * maxSlope <= 0) { /* Crosses zero, range is split */ } 
                    else {
                        const b1 = -c1 / minSlope; const b2 = -c1 / maxSlope;
                        c2_l = Math.min(b1, b2); c2_u = Math.max(b1, b2);
                    }
                }
                optimalityBody.innerHTML = `
                    <tr><td class="px-6 py-4">x의 계수 (c1)</td><td class="px-6 py-4">${formatNumber(c1_l)}</td><td class="px-6 py-4">${formatNumber(c1)}</td><td class="px-6 py-4">${formatNumber(c1_u)}</td></tr>
                    <tr><td class="px-6 py-4">y의 계수 (c2)</td><td class="px-6 py-4">${formatNumber(c2_l)}</td><td class="px-6 py-4">${formatNumber(c2)}</td><td class="px-6 py-4">${formatNumber(c2_u)}</td></tr>`;
            }

            parsedConstraints.forEach(c => {
                let shadowPrice = 0; const isBinding = bindingConstraints.includes(c);
                if (isBinding && bindingConstraints.length >= 2) {
                    const other = bindingConstraints.find(bc => bc !== c);
                    if (other) {
                        const p1 = { ...c, value: c.value + 1 }, p2 = other;
                        const det = p1.coeffs.x * p2.coeffs.y - p1.coeffs.y * p2.coeffs.x;
                        if (Math.abs(det) > EPSILON) {
                            const x_new = (p2.coeffs.y * p1.value - p1.coeffs.y * p2.value) / det;
                            const y_new = (p1.coeffs.x * p2.value - p2.coeffs.x * p1.value) / det;
                            shadowPrice = (c1 * x_new + c2 * y_new) - optimalSolution.value;
                        }
                    }
                }
                const row = document.createElement('tr');
                row.innerHTML = `<td class="px-6 py-4">${c.original.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</td><td class="px-6 py-4">${isBinding ? formatNumber(shadowPrice) : '0 <span class="text-slate-400">(Non-binding)</span>'}</td>`;
                shadowBody.appendChild(row);
            });
        }
    </script>
</body>
</html>

